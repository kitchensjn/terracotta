# Topics

- Outline of algorithm
- Improvement to exponentiation algorithm
- `tile_shapefile()`

---

### From 2025-08-01 to 2025-09-28

#### Outline of algorithm
- Bin node times in trees - fast enough and done once
- Deconstruct `tskit.TreeSequences` into primitive objects. This is necessary for using `numba` (GPU accelerated parallel processing) - done once
    - `children` : list of #nodes x #nodes array, one per tree. 0 except 1 when y is parent of x. Nodes ordered by time ascending
    - `branch_above` : list of #nodes x 1 arrays of branch times ordered by node time ascending
    - `roots` : list of #roots x 1 arrays with the root node IDs of each tree
- Create list of all branch lengths in ARG - fast and done once
- Build the transition matrix ($Q$) based on the specified migration rates - fast and done once per migration rate combination
- Compute the transitions of matrices that will be used for each branch length ($e^{Qt}$) - slow and done once per migration rate
    - I've sped this up with $M = (e^Q)^{t_1} = (e^Q)^{t_0}(e^Q)^{t_1-t_0}$. This accumulates errors as $t$ increases due to floating point imprecision, but errors appear small (first mentioned in `devlog20250501`)
- Create sample vectors - fast and done once per migration rate combination (though could be done only once if passed as parameter into this function)
- For each tree, traverse from tip to root - 20 secs for 100 trees
    - Combine all child messages and apply transition matrix


#### Improvement to exponentiation algorithm
Precomputing the transition probabilities remains one of the slowest aspects of this algorithm. Exponentiation needs to be done for each branch length and each instantaneous rate matrix (Q). The current implement (described above in the algorithm outline) builds from smallest to largest branch lengths, utilizing the previous result to avoid redundant calculations. This still requires the calculation of $(e^Q)^{t_1-t_0}$ which can potentially be slow. An example scenario where this can be improved significantly is with branch lengths `[1,10,100,1000]`. Recognizing that $(e^Q)^{100}$ is $((e^Q)^{10})^{2}$, $2$ is a lot smaller than $100-10=90$, so raising to $2$ is much faster to calculate. If we check whether previous branch lengths are factors of the current branch length, we can raise that result to a smaller power rather than calculation $(e^Q)^{100-10}$.

Graham mentioned that there might not be a need to standard exponentiation at all using a function like [scipy.sparse.linalg.expm_multiply()](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.expm_multiply.html). I'll need to look into this though I'm not sure that it will improve things because the exponentiation isn't the slowest part now... (that is a guess and needs to be checked).

#### `tile_shapefile()`

Though users can make their `demes.tsv` in whatever way suits their system, I think it's still important to give some guidance to users. `tile_shapefile()` is a small function to add the H3 global grid to a shapefile. I should add instructions for how use this to build the `demes.tsv`.