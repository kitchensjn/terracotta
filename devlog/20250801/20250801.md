# Topics

- Outline of algorithm

---

### From 2025-08-01 to

```{python}
def calc_migration_rate_log_likelihood(migration_rates, world_map, children, branch_above, roots, branch_lengths):
    """Calculates the composite log-likelihood of the specified migration rates across trees
    
    Loops through all trees and calculates the log-likelihood for each, before summing together.

    Parameters
    ----------
    world_map : terracotta.WorldMap
    trees : list
        List of tskit.Tree objects
    migration_rates : dict
        Keys are the connection type and values are the instantaneous migration
        rate along that connection
    branch_lengths : np.array

    Returns
    -------
    mr_log_like : float
        Log-likelihood of the specified migration rates
    """

    transition_matrix = world_map.build_transition_matrix(migration_rates=migration_rates)
    precomputed_transitions, precomputed_log = precalculate_transitions(
        branch_lengths=branch_lengths,
        transition_matrix=transition_matrix
    )
    sample_locations_array, sample_ids = world_map._build_sample_locations_array()
    like, like_list = _parallel_process_trees(
        children=children,
        branch_above=branch_above,
        roots=roots,
        sample_ids=sample_ids,
        sample_location_vectors=sample_locations_array,
        branch_lengths=branch_lengths,
        precomputed_transitions=precomputed_transitions,
        precomputed_log=precomputed_log
    )
    print(migration_rates, abs(like), flush=True)
    return abs(like)
```

- Bin node times in trees - fast enough and done once
- Deconstruct `tskit.TreeSequences` into primitive objects. This is necessary for using `numba` (GPU accelerated parallel processing) - done once
    - `children` : list of #nodes x #nodes array, one per tree. 0 except 1 when y is parent of x. Nodes ordered by time ascending
    - `branch_above` : list of #nodes x 1 arrays of branch times ordered by node time ascending
    - `roots` : list of #roots x 1 arrays with the root node IDs of each tree
- Create list of all branch lengths in ARG - fast and done once
- Build the transition matrix ($Q$) based on the specified migration rates - fast and done once per migration rate combination
- Compute the transitions of matrices that will be used for each branch length ($e^{Qt}$) - slow and done once per migration rate
    - I've sped this up with $M = (e^Q)^{t_1} = (e^Q)^{t_0}(e^Q)^{t_1-t_0}$. This accumulates errors as $t$ increases due to floating point imprecision, but errors appear small.
- Create sample vectors - fast and done once per migration rate combination (though could be done only once if passed as parameter into this function)
- For each tree, traverse from tip to root - 20 secs for 100 trees
    - Combine all child messages and apply transition matrix
