# Topics

- Epochs

---

### From 2025-09-29 to

#### Epochs

```
id	xcoord	ycoord	type	neighbours
0	24.35554546084572	70.69582613722945	0	29,33
1	140.24900275289315	72.16123648187042	0	6,7
2	141.40923257425092	66.81847831948762	1	3,4,5,6,7,8
3	149.27222925193394	66.81693984187014	0	2,5,7,11,13,179
4	138.30973121891174	64.06476794657276	1	2,5,8,141,142,163
```

Above is an example `demes.tsv`. Currently, deme types are given one type for the whole back propagation. You could see a scenario where conditions change over time, constituting a need for a different migration rate and therefore deme type. If only one number is given, we can assume that the rate is the same the whole time. Alternatively, if type is set to `0:0,100:4`, I am saying that from 0 to 100 generations before present, the deme is of type `0`, then deeper than 100 generations, it is of type `4`. This ensures that types are shared across epochs, which will give more power to the estimates. So far this seems like the most compact way of doing this, as the connections don't change between epochs, so we don't want a completely new `demes.tsv` file. This format won't make sense to the `pandas`, so further processing will be required to get these into `WorldMap.connections`. Rather than `WorldMap.connections` being a single `pandas.DataFrame`, it needs to be a list with associated epochs.

**Returning to this** - I'm allowing `demes.tsv` to have either `0` or `0:0` format for specifying that the deme is of type 0 for the entire duration. When this is converted to a `WorldMap`, it will always be changed to `0:0`. This ensures that the column is always a string and of a consistent format, versus having to handle different data types (which quickly became a nightmare so I rethought and streamlined).

Today, I implemented some of these changes. The algorithm has not been updated to address the new epochs format, but I'm getting close. The major difference is that `WorldMap.connections` is now a list of `pandas.DataFrames` with an associated list `WorldMap.epochs` that gives the start time of each epoch. As a warm-up to this new format, I started by updating `WorldMap.draw()` to capture the map at different time points. That's not quite done, but it's close.

![World Map With Epochs](assets/epochs/figures/world_map_epochs.png)

Now, it draws a world map for each epoch. In this example only one deme changes type between maps, but you can imagine everything changing. The new `draw()` does not have all of the features of the old draw, such as plotting sample locations, and that is a conscious decision because I felt like things were getting too cluttered. I may revisit that later.

I realized that the dataset creation functions, such as `create_trees_files()`, needed to be updated to allow for changing rates. `msprime.Demography().add_migration_rate_change()` allows for migration rates to be changed at specified times. I reworked `_set_up_msprime_demography()` now that `WorldMap.connections` is a list. It now loops over the list and whenever there's a rate change, it adds a demographic event at the epoch time with the new rate.

![World map with a barrier in the recent past](assets/epochs/figures/world_map_barrier.png)

A clear example of this is when there is a barrier in the recent past but not in the deep past. If blue and dark pink transitions have the same rate, and light pink has a rate of 0, you will get coalescence events between samples found in the same deme type but not different until 10,000 generations in the past when the map changes.

```
13275.02┊                     30                ┊
        ┊                ┏━━━━━┻━━━━━┓          ┊
1055.15 ┊                ┃          29          ┊
        ┊                ┃      ┏━━━━┻━━━━┓     ┊
527.10  ┊               28      ┃         ┃     ┊
        ┊             ┏━━┻━━┓   ┃         ┃     ┊
457.45  ┊             ┃     ┃   ┃        27     ┊
        ┊             ┃     ┃   ┃       ┏━┻━━┓  ┊
333.47  ┊            26     ┃   ┃       ┃    ┃  ┊
        ┊         ┏━━━┻━━┓  ┃   ┃       ┃    ┃  ┊
238.99  ┊        25      ┃  ┃   ┃       ┃    ┃  ┊
        ┊     ┏━━━┻━━━┓  ┃  ┃   ┃       ┃    ┃  ┊
192.50  ┊     ┃       ┃  ┃  ┃   ┃      24    ┃  ┊
        ┊     ┃       ┃  ┃  ┃   ┃     ┏━┻━┓  ┃  ┊
188.27  ┊     ┃       ┃  ┃  ┃  23     ┃   ┃  ┃  ┊
        ┊     ┃       ┃  ┃  ┃  ┏┻━┓   ┃   ┃  ┃  ┊
172.27  ┊    22       ┃  ┃  ┃  ┃  ┃   ┃   ┃  ┃  ┊
        ┊   ┏━┻━┓     ┃  ┃  ┃  ┃  ┃   ┃   ┃  ┃  ┊
127.24  ┊   ┃  21     ┃  ┃  ┃  ┃  ┃   ┃   ┃  ┃  ┊
        ┊   ┃  ┏┻━┓   ┃  ┃  ┃  ┃  ┃   ┃   ┃  ┃  ┊
124.82  ┊   ┃  ┃  ┃   ┃  ┃  ┃ 20  ┃   ┃   ┃  ┃  ┊
        ┊   ┃  ┃  ┃   ┃  ┃  ┃ ┏┻┓ ┃   ┃   ┃  ┃  ┊
114.62  ┊  19  ┃  ┃   ┃  ┃  ┃ ┃ ┃ ┃   ┃   ┃  ┃  ┊
        ┊ ┏━┻┓ ┃  ┃   ┃  ┃  ┃ ┃ ┃ ┃   ┃   ┃  ┃  ┊
107.37  ┊ ┃  ┃ ┃  ┃   ┃  ┃  ┃ ┃ ┃ ┃   ┃   ┃ 18  ┊
        ┊ ┃  ┃ ┃  ┃   ┃  ┃  ┃ ┃ ┃ ┃   ┃   ┃ ┏┻┓ ┊
58.53   ┊ ┃  ┃ ┃  ┃  17  ┃  ┃ ┃ ┃ ┃   ┃   ┃ ┃ ┃ ┊
        ┊ ┃  ┃ ┃  ┃ ┏━┻┓ ┃  ┃ ┃ ┃ ┃   ┃   ┃ ┃ ┃ ┊
29.30   ┊ ┃  ┃ ┃  ┃ ┃  ┃ ┃  ┃ ┃ ┃ ┃  16   ┃ ┃ ┃ ┊
        ┊ ┃  ┃ ┃  ┃ ┃  ┃ ┃  ┃ ┃ ┃ ┃ ┏━┻┓  ┃ ┃ ┃ ┊
0.00    ┊ 0 15 4 12 6 14 2 10 1 3 8 5 13 11 7 9 ┊
        0                                       1
```

This results in trees like the one above, which shows that the simulation is working as expected. I'm pretty happy with this so think it's time to move on to the belief propagation algorithm.